<!DOCTYPE html PUBLIC >
<html >
<head>
	<script type="text/javascript" src="timer.js"></script>
	<script type="text/javascript" src="checker.js"></script>
	<script type="text/javascript" src="copyPaste.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<script type="text/javascript">
		var xmlhttp;
		if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
			xmlhttp=new XMLHttpRequest();
		} else {	// code for IE6, IE5
			xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
		}
		xmlhttp.onreadystatechange=function() {
		if (xmlhttp.readyState == 4 && xmlhttp.status == "200") {
			var parser = new DOMParser();
			var xmlDoc = parser.parseFromString(xmlhttp.responseText, "application/xml");
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
			var test = parseResponse(xmlDoc);
			alert(JSON.stringify(test) + '\n' + xmlDoc.childNodes.length);
		}
	}
	//	This is separate from the recursion function because that's what it needs to be for the recursion to work. :)
	function parseResponse(responseXMLDOM) {
		// Technically, these 2 lines could be one line. I don't know why I always make them 2.
		var ret = {};
		ret = recurseTree(responseXMLDOM);
		return ret;
	}
	
	//	Hopefully recursion makes some sense to you.
	//	Basically, it's perfect for traversing tree-like data... Eg XML
	function recurseTree(element) {
		//	Initialize the return value;
		var ret = {};
		//	If the current node has children then it's not text... get the children.
		if(element !== null) {
			if(element.hasChildNodes()) {
				for(var i=0;i<element.childNodes.length;i++) {
					//	Here's where the recusion magic happens.
					//	If the element is text there will be an immediate return.
					//	If the element contains children then we'll get some recursive looping!
					ret[element.childNodes[i].tagName] = recurseTree(element.childNodes[i]);
				}
			} else {
				//	Text should be the property of a node that contains text.
				//	There may be node types we're missing here, so watch for them... somehow.
				ret[element.tagName] = element.text;
			}
			//	Beware - this return happens a lot while the DOM is processing.
		}
		return ret;
	}
	</script>
<title>WPM Final</title>
</head>
<body>
	<input type="button" value=" Start Test " onclick="buttonClick();"/>
	<div id="myDiv">
	</div>
	<script>
		function buttonClick() {
			xmlhttp.open("GET","wpmtest.php",false);
			xmlhttp.send();
		}
	</script>
	<input type="button" value=" Get Score " onclick="scoreButtonClick();"/>
	<script>
	function scoreButtonClick() {
		xmlhttp.open("GET","score.php",false);
		xmlhttp.send();
	}
	</script>
</body>
</html>
